<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
  <BODY>

<center>
<h2>Homework Assignment
02

</h2>
<h3>C++ Object Models</h3>
</center>


<h3>Contents:</h3>
<UL>
  <LI>
      <a href="#overview">Overview</a>
  </LI>
  <LI>
      <a href="#submit">Problems to be Submitted</a>
  </LI>
  <LI>
      <a href="#extra">Extra Credit</a>
  </LI>
</UL>

<hr>

<a name="overview"><h3>Overview</h3></a>

<P>
Our goal of this homework is to review some of the subtleties of
object-oriented programming in C++, as seen in our walkthrough of the
our "Objects Demo"
</P>

<P>
<b>Topic:</b>  C++ Object Models
<br>
<b>Related Reading:</b>  Section&nbsp;8 of Transition Guide and
Ch.&nbsp;1.1.3, 1.4.1, 1.5.2 of text.
<br>
<b>Due:</b>
Wed, 18 September 2019, 9:00am (Turn-in by paper)

</P>

<hr>

<a name="submit"><h3>Problems to be Submitted (20 points)</h3></a>

<ol type = "A"> 

<LI> (6 points)

<p>    
Draw a diagram such as the one shown below, to portray the
underlying memory configuration that might exist after the
completion of the following series of commands (you may assume
that one cell of memory is sufficient for storing a character or a
pointer).

    <pre>
char a('X');
char b('Y');
char *c(&b);    
char d(a);
char &e(a);
char *f(c);
char *g(new char('Z'));
    </pre>

    <br><img src="figs/memory.gif">
    <br>
<p>
Based upon your solution in the first diagram,
give a second diagram that portrays    
the updated configuration after the following
additional commands.

    <pre>
*f = 'W';
c = g;
e = b;
    </pre>
    
</LI>
    

<li> (6 points)
    <p>
    This problem explores variants in argument passing.

    What (if anything) is different about the behavior of the
    following three functions <tt>f()</tt>, <tt>g()</tt> and
    <tt>h()</tt>?

<PRE>
  void f(int x) {
    x = x + 1;
    cout << x;
  }
  
  void g(int& x) {
    x = x + 1;
    cout << x;
  }
  
  void h(const int& x) {
    x = x + 1;
    cout << x;
  }
  
</PRE>
    

    </p>
</LI>


<LI> (8 points)

    <p>
    This problem explores static vs. dynamic allocation of objects and
    the use of the assignment operator and copy constructor.
    Most of this material is covered in some form as
    part of of Ch.&nbsp;P.5 of the text.
    </p>
    
    <p>
    Assume that we begin with the definition of a basic Thing class
    (similar to the one which we saw in class, but without all the
    extraneous chatter), and then the following declarations within
    the main function:
    <blockquote>
<tt>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;    

class Thing {
  private:
    string book;
  public:
    Thing(string initialBook = "Cat in the Hat") : book(initialBook) { }
    string getBook() const { return book; }
    void setBook(string bk) { book = bk; }
};    
    
int main() {
    Thing a;
    Thing b("Snow");
    Thing c(b);
    Thing *d(&c);
    Thing *e(new Thing());
    Thing *f(new Thing(b));

    // ... more to come ...
}    
</pre>    
</tt>
    </blockquote>
    </p>

<p>
    To begin, we want you to draw a diagram using a style similar to
    examples in class on the blackboard, showing the underlying memory
    configuration that results from the above statements.   Although
    you could experiement with such code on a computer, you are
    welcome to do this as a hypothetical.  To get you going, here is
    the style of picture that we'd have in mind after the first
    two declaration.
    <br><img src="figs/step2.gif">
    <br>
    Note that the "memory address" we give on the right have no basis
    in reality. The actual addresses and the placement of the objects
    would be system dependent (and typically would be displayed in
    hexadecimal). Yet we are assuming that storage for each Thing
    instance requires two cells of memory.
</p>
    

    <p>
    And now, onto the real problem.
    <OL type = "i">
    <li>
    <p>
    Complete the memory diagram to reflect the state of affairs after
    all six of the original declaration statements above.
    </p>
    <p>
    Then predict the output that would be given at this point by the
    following code fragment.  Do not simply give the generated output,
    but explain <u>why</u> such output is generated.
        <TT>
        <blockquote>
        cout &lt;&lt; a.getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; b.getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; c.getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; d-&gt;getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; e-&gt;getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; f-&gt;getBook() &lt;&lt; endl;<br>
        </blockquote>
        </TT>
    </LI>
      </OL>

    <P>
    For each subsequent part of this problem, consider the new line of
    code as if it were executed immediately following the
    initial block of code given above (that is, <u>do not let the
    code from part&nbsp;ii affect your answer to part&nbsp;iii, etc.</u>).
    </p>
    
    <OL type = "i" start=2>
    <LI>
        Update your initial memory diagram to reflect the
        additional command
        <TT>
        <blockquote>
        b.setBook("Hop on Pop");<br>
        </blockquote>
        </TT>
        and then explain what output would be generated by the
        following.
        <TT>
        <blockquote>
        cout &lt;&lt; a.getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; b.getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; c.getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; d-&gt;getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; e-&gt;getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; f-&gt;getBook() &lt;&lt; endl;<br>
        </blockquote>
        </TT>
    </LI>
    <LI>
        Update your initial memory diagram to reflect the
        additional command
        <TT>
        <blockquote>
        c.setBook("Hop on Pop");<br>
        </blockquote>
        </TT>
        and then explain what output would be generated by the
        following.
        <TT>
        <blockquote>
        cout &lt;&lt; a.getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; b.getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; c.getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; d-&gt;getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; e-&gt;getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; f-&gt;getBook() &lt;&lt; endl;<br>
        </blockquote>
        </TT>
    </LI>
    <LI>
        Update your initial memory diagram to reflect the
        additional command
        <TT>
        <blockquote>
        a = b;<br>
        </blockquote>
        </TT>
        and then explain what output would be generated by the
        following.
        <TT>
        <blockquote>
        cout &lt;&lt; a.getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; b.getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; c.getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; d-&gt;getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; e-&gt;getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; f-&gt;getBook() &lt;&lt; endl;<br>
        </blockquote>
        </TT>
    </LI>
    <LI>
        Update your initial memory diagram to reflect the
        additional command
        <TT>
        <blockquote>
        b = a;<br>
        </blockquote>
        </TT>
        and then explain what output would be generated by the
        following.
        <TT>
        <blockquote>
        cout &lt;&lt; a.getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; b.getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; c.getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; d-&gt;getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; e-&gt;getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; f-&gt;getBook() &lt;&lt; endl;<br>
        </blockquote>
        </TT>
    </LI>
    <LI>
        Update your initial memory diagram to reflect the
        additional commands
        <TT>
        <blockquote>
        b = a;<br>
        a.setBook("Hop on Pop");<br>
        </blockquote>
        </TT>
        and then explain what output would be generated by the
        following.
        <TT>
        <blockquote>
        cout &lt;&lt; a.getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; b.getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; c.getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; d-&gt;getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; e-&gt;getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; f-&gt;getBook() &lt;&lt; endl;<br>
        </blockquote>
        </TT>
    </LI>

    <LI>
        Update your initial memory diagram to reflect the
        additional commands
        <TT>
        <blockquote>
        e = d;<br>
        d-&gt;setBook("Hop on Pop");
        </blockquote>
        </TT>
        and then explain what output would be generated by the
        following.
        <TT>
        <blockquote>
        cout &lt;&lt; a.getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; b.getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; c.getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; d-&gt;getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; e-&gt;getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; f-&gt;getBook() &lt;&lt; endl;<br>
        </blockquote>
        </TT>
    </LI>

          <LI>
        Update your initial memory diagram to reflect the
        additional commands
        <TT>
        <blockquote>
        *e = *d;<br>
        d-&gt;setBook("Hop on Pop");
        </blockquote>
        </TT>
        and then explain what output would be generated by the
        following.
        <TT>
        <blockquote>
        cout &lt;&lt; a.getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; b.getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; c.getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; d-&gt;getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; e-&gt;getBook() &lt;&lt; endl;<br>
        cout &lt;&lt; f-&gt;getBook() &lt;&lt; endl;<br>
        </blockquote>
        </TT>
    </LI>
      </OL>
</LI>



    
</OL>

<hr>

  </body>
</html>
